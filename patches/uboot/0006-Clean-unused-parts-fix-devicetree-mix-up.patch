From 44f2635ccfd38cd48eb4e597ffbac0ae1e8c0ed6 Mon Sep 17 00:00:00 2001
From: Alvaro-Karsz <alvaro.karsz@solid-run.com>
Date: Tue, 19 Oct 2021 16:07:13 +0300
Subject: [PATCH] Clean unused parts + fix devicetree mix up

* Clean board c code file, remove unused parts (board detect for example).
* Add a -u-boot.dtsi file and change CONFIG_OF_LIST, so our device-tree will be used instead of EVM's (was selected in CONFIG_OF_LIST).
---
 arch/arm/dts/am642-solidrun-u-boot.dtsi       | 149 ++++++
 arch/arm/dts/am642-solidrun.dts               |   5 +-
 arch/arm/dts/am64x-solidrun-r5.dts            |   3 +-
 .../solidrun/am64x_solidrun/am64x_solidrun.c  | 112 +----
 board/solidrun/common/ti_board_detect.h       | 471 ------------------
 configs/am64x_a53_solidrun_defconfig          |   2 +-
 configs/am64x_r5_solidrun_defconfig           |   1 -
 7 files changed, 158 insertions(+), 585 deletions(-)
 create mode 100644 arch/arm/dts/am642-solidrun-u-boot.dtsi
 delete mode 100644 board/solidrun/common/ti_board_detect.h

diff --git a/arch/arm/dts/am642-solidrun-u-boot.dtsi b/arch/arm/dts/am642-solidrun-u-boot.dtsi
new file mode 100644
index 00000000..d066973f
--- /dev/null
+++ b/arch/arm/dts/am642-solidrun-u-boot.dtsi
@@ -0,0 +1,149 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Texas Instruments Incorporated - https://www.ti.com/
+ */
+
+/ {
+	chosen {
+		stdout-path = "serial2:115200n8";
+		tick-timer = &timer1;
+	};
+
+	aliases {
+		ethernet0 = &cpsw3g;
+	};
+};
+
+&cbass_main{
+	u-boot,dm-spl;
+	timer1: timer@2400000 {
+		compatible = "ti,omap5430-timer";
+		reg = <0x0 0x2400000 0x0 0x80>;
+		ti,timer-alwon;
+		clock-frequency = <25000000>;
+		u-boot,dm-spl;
+	};
+};
+
+&main_conf {
+	u-boot,dm-spl;
+	chipid@14 {
+		u-boot,dm-spl;
+	};
+};
+
+&main_pmx0 {
+	u-boot,dm-spl;
+	main_i2c0_pins_default: main-i2c0-pins-default {
+		u-boot,dm-spl;
+		pinctrl-single,pins = <
+			AM64X_IOPAD(0x0260, PIN_INPUT_PULLUP, 0) /* (A18) I2C0_SCL */
+			AM64X_IOPAD(0x0264, PIN_INPUT_PULLUP, 0) /* (B18) I2C0_SDA */
+		>;
+	};
+};
+
+&main_i2c0 {
+	u-boot,dm-spl;
+	pinctrl-names = "default";
+	pinctrl-0 = <&main_i2c0_pins_default>;
+	clock-frequency = <400000>;
+};
+
+&main_uart0 {
+	u-boot,dm-spl;
+};
+
+&usb0 {
+	dr_mode="peripheral";
+	u-boot,dm-spl;
+};
+
+&usbss0 {
+	u-boot,dm-spl;
+};
+
+&main_usb0_pins_default {
+	u-boot,dm-spl;
+};
+
+&dmss {
+	u-boot,dm-spl;
+};
+
+&secure_proxy_main {
+	u-boot,dm-spl;
+};
+
+&dmsc {
+	u-boot,dm-spl;
+	k3_sysreset: sysreset-controller {
+		compatible = "ti,sci-sysreset";
+		u-boot,dm-spl;
+	};
+};
+
+&k3_pds {
+	u-boot,dm-spl;
+};
+
+&k3_clks {
+	u-boot,dm-spl;
+};
+
+&k3_reset {
+	u-boot,dm-spl;
+};
+
+&sdhci0 {
+	u-boot,dm-spl;
+};
+
+&sdhci1 {
+	no-1-8-v;
+	u-boot,dm-spl;
+};
+
+&cpsw3g {
+	reg = <0x0 0x8000000 0x0 0x200000>,
+	      <0x0 0x43000200 0x0 0x8>;
+	reg-names = "cpsw_nuss", "mac_efuse";
+	/delete-property/ ranges;
+
+	cpsw-phy-sel@04044 {
+		compatible = "ti,am64-phy-gmii-sel";
+		reg = <0x0 0x43004044 0x0 0x8>;
+	};
+};
+
+&cpsw_port2 {
+	status = "disabled";
+};
+
+&main_bcdma {
+	u-boot,dm-spl;
+};
+
+&main_pktdma {
+	u-boot,dm-spl;
+};
+
+&ospi0_pins_default {
+	u-boot,dm-spl;
+};
+
+&fss {
+	u-boot,dm-spl;
+};
+
+&ospi0 {
+	u-boot,dm-spl;
+
+	flash@0 {
+		u-boot,dm-spl;
+
+		partition@3fc0000 {
+			u-boot,dm-spl;
+		};
+	};
+};
diff --git a/arch/arm/dts/am642-solidrun.dts b/arch/arm/dts/am642-solidrun.dts
index 0731c08a..6370cf60 100644
--- a/arch/arm/dts/am642-solidrun.dts
+++ b/arch/arm/dts/am642-solidrun.dts
@@ -12,7 +12,7 @@
 
 / {
 	compatible =  "ti,am642-evm", "ti,am642";
-	model = "Texas Instruments AM642 EVM";
+	model = "Texas Instruments AM642 SolidRun Board";
 
 	chosen {
 		stdout-path = "serial2:115200n8";
@@ -22,8 +22,7 @@
 	memory@80000000 {
 		device_type = "memory";
 		/* 1G RAM */
-		reg = <0x00000000 0x40000000 0x00000000 0x40000000>;
-
+                reg = <0x0 0x80000000 0 0x40000000>;
 	};
 
 	reserved-memory {
diff --git a/arch/arm/dts/am64x-solidrun-r5.dts b/arch/arm/dts/am64x-solidrun-r5.dts
index 7246fb1f..578a57e1 100644
--- a/arch/arm/dts/am64x-solidrun-r5.dts
+++ b/arch/arm/dts/am64x-solidrun-r5.dts
@@ -23,8 +23,7 @@
 	memory@80000000 {
 		device_type = "memory";
 		/* 1G RAM */
-		reg = <0x00000000 0x40000000 0x00000000 0x40000000>;
-
+                reg = <0x0 0x80000000 0 0x40000000>;
 	};
 
 	a53_0: a53@0 {
diff --git a/board/solidrun/am64x_solidrun/am64x_solidrun.c b/board/solidrun/am64x_solidrun/am64x_solidrun.c
index ca160604..8bfe1762 100644
--- a/board/solidrun/am64x_solidrun/am64x_solidrun.c
+++ b/board/solidrun/am64x_solidrun/am64x_solidrun.c
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * Board specific initialization for AM642 EVM
+ * Board specific initialization for AM64X Based SolidRun board
  *
- * Copyright (C) 2020 Texas Instruments Incorporated - https://www.ti.com/
- *	Keerthy <j-keerthy@ti.com>
+ * Copyright (C) 2021 SolidRun
+ *	Alvaro Karsz <alvaro.karsz@solid-run.com>
  *
  */
 
@@ -15,11 +15,6 @@
 #include <asm/arch/sys_proto.h>
 
 
-#include "../common/ti_board_detect.h"
-
-#define board_is_am64x_gpevm()	board_ti_k3_is("AM64-GPEVM")
-#define board_is_am64x_skevm()	board_ti_k3_is("AM64-SKEVM")
-
 DECLARE_GLOBAL_DATA_PTR;
 
 int board_init(void)
@@ -42,95 +37,15 @@ int dram_init_banksize(void)
 
 	return 0;
 }
+
 #ifdef CONFIG_SPL_LOAD_FIT
 int board_fit_config_name_match(const char *name)
 {
-	bool eeprom_read = board_ti_was_eeprom_read();
-
-	if (!eeprom_read || board_is_am64x_gpevm()) {
-		if (!strcmp(name, "k3-am642-r5-evm") || !strcmp(name, "k3-am642-evm"))
-			return 0;
-	} else if (board_is_am64x_skevm()) {
-		if (!strcmp(name, "k3-am642-r5-sk") || !strcmp(name, "k3-am642-sk"))
-			return 0;
-	}
-
-	return -1;
-}
-#endif
-
-#ifdef CONFIG_TI_I2C_BOARD_DETECT
-int do_board_detect(void)
-{
-	int ret;
-
-	ret = ti_i2c_eeprom_am6_get_base(CONFIG_EEPROM_BUS_ADDRESS,
-					 CONFIG_EEPROM_CHIP_ADDRESS);
-	if (ret) {
-		printf("EEPROM not available at %d, trying to read at %d\n",
-			CONFIG_EEPROM_CHIP_ADDRESS, CONFIG_EEPROM_CHIP_ADDRESS + 1);
-		ret = ti_i2c_eeprom_am6_get_base(CONFIG_EEPROM_BUS_ADDRESS,
-						 CONFIG_EEPROM_CHIP_ADDRESS + 1);
-		if (ret)
-			pr_err("Reading on-board EEPROM at 0x%02x failed %d\n",
-			       CONFIG_EEPROM_CHIP_ADDRESS + 1, ret);
-	}
-
-	return ret;
-}
-
-int checkboard(void)
-{
-	struct ti_am6_eeprom *ep = TI_AM6_EEPROM_DATA;
-
-	if (!do_board_detect())
-		printf("Board: %s rev %s\n", ep->name, ep->version);
-
 	return 0;
 }
-
-#ifdef CONFIG_BOARD_LATE_INIT
-static void setup_board_eeprom_env(void)
-{
-	char *name = "am64x_gpevm";
-
-	if (do_board_detect())
-		goto invalid_eeprom;
-
-	if (board_is_am64x_gpevm())
-		name = "am64x_gpevm";
-	else if (board_is_am64x_skevm())
-		name = "am64x_skevm";
-	else
-		printf("Unidentified board claims %s in eeprom header\n",
-		       board_ti_get_name());
-
-invalid_eeprom:
-	set_board_info_env_am6(name);
-}
-
-static void setup_serial(void)
-{
-	struct ti_am6_eeprom *ep = TI_AM6_EEPROM_DATA;
-	unsigned long board_serial;
-	char *endp;
-	char serial_string[17] = { 0 };
-
-	if (env_get("serial#"))
-		return;
-
-	board_serial = simple_strtoul(ep->serial, &endp, 16);
-	if (*endp != '\0') {
-		pr_err("Error: Can't set serial# to %s\n", ep->serial);
-		return;
-	}
-
-	snprintf(serial_string, sizeof(serial_string), "%016lx", board_serial);
-	env_set("serial#", serial_string);
-}
-#endif
 #endif
 
+
 #ifdef CONFIG_BOARD_LATE_INIT
 
 
@@ -245,26 +160,9 @@ void initPhy(void)
 
 int board_late_init(void)
 {
-
 	/*init PHY*/
 	initPhy();
 
-
-
-	if (IS_ENABLED(CONFIG_TI_I2C_BOARD_DETECT)) {
-		struct ti_am6_eeprom *ep = TI_AM6_EEPROM_DATA;
-
-		setup_board_eeprom_env();
-		setup_serial();
-		/*
-		 * The first MAC address for ethernet a.k.a. ethernet0 comes from
-		 * efuse populated via the am654 gigabit eth switch subsystem driver.
-		 * All the other ones are populated via EEPROM, hence continue with
-		 * an index of 1.
-		 */
-		board_ti_am6_set_ethaddr(1, ep->mac_addr_cnt);
-	}
-
 	return 0;
 }
 #endif
diff --git a/board/solidrun/common/ti_board_detect.h b/board/solidrun/common/ti_board_detect.h
deleted file mode 100644
index de7cb52d..00000000
--- a/board/solidrun/common/ti_board_detect.h
+++ /dev/null
@@ -1,471 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Library to support early TI EVM EEPROM handling
- *
- * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com
- */
-
-#ifndef __BOARD_DETECT_H
-#define __BOARD_DETECT_H
-
-/* TI EEPROM MAGIC Header identifier */
-#include <linux/bitops.h>
-#define TI_EEPROM_HEADER_MAGIC	0xEE3355AA
-#define TI_DEAD_EEPROM_MAGIC	0xADEAD12C
-
-#define TI_EEPROM_HDR_NAME_LEN		8
-#define TI_EEPROM_HDR_REV_LEN		4
-#define TI_EEPROM_HDR_SERIAL_LEN	12
-#define TI_EEPROM_HDR_CONFIG_LEN	32
-#define TI_EEPROM_HDR_NO_OF_MAC_ADDR	3
-#define TI_EEPROM_HDR_ETH_ALEN		6
-
-/**
- * struct ti_am_eeprom - This structure holds data read in from the
- *                     AM335x, AM437x, AM57xx TI EVM EEPROMs.
- * @header: This holds the magic number
- * @name: The name of the board
- * @version: Board revision
- * @serial: Board serial number
- * @config: Reserved
- * @mac_addr: Any MAC addresses written in the EEPROM
- *
- * The data is this structure is read from the EEPROM on the board.
- * It is used for board detection which is based on name. It is used
- * to configure specific TI boards. This allows booting of multiple
- * TI boards with a single MLO and u-boot.
- */
-struct ti_am_eeprom {
-	unsigned int header;
-	char name[TI_EEPROM_HDR_NAME_LEN];
-	char version[TI_EEPROM_HDR_REV_LEN];
-	char serial[TI_EEPROM_HDR_SERIAL_LEN];
-	char config[TI_EEPROM_HDR_CONFIG_LEN];
-	char mac_addr[TI_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
-} __attribute__ ((__packed__));
-
-/* AM6x TI EVM EEPROM Definitions */
-#define TI_AM6_EEPROM_RECORD_BOARD_ID		0x01
-#define TI_AM6_EEPROM_RECORD_BOARD_INFO		0x10
-#define TI_AM6_EEPROM_RECORD_DDR_INFO		0x11
-#define TI_AM6_EEPROM_RECORD_DDR_SPD		0x12
-#define TI_AM6_EEPROM_RECORD_MAC_INFO		0x13
-#define TI_AM6_EEPROM_RECORD_END_LIST		0xFE
-
-/*
- * Common header for AM6x TI EVM EEPROM records. Used to encapsulate the config
- * EEPROM in its entirety as well as for individual records contained within.
- */
-struct ti_am6_eeprom_record_header {
-	u8 id;
-	u16 len;
-} __attribute__ ((__packed__));
-
-/* AM6x TI EVM EEPROM board ID structure */
-struct ti_am6_eeprom_record_board_id {
-	u32 magic_number;
-	struct ti_am6_eeprom_record_header header;
-} __attribute__ ((__packed__));
-
-/* AM6x TI EVM EEPROM board info structure */
-#define AM6_EEPROM_HDR_NAME_LEN			16
-#define AM6_EEPROM_HDR_VERSION_LEN		2
-#define AM6_EEPROM_HDR_PROC_NR_LEN		4
-#define AM6_EEPROM_HDR_VARIANT_LEN		2
-#define AM6_EEPROM_HDR_PCB_REV_LEN		2
-#define AM6_EEPROM_HDR_SCH_BOM_REV_LEN		2
-#define AM6_EEPROM_HDR_SW_REV_LEN		2
-#define AM6_EEPROM_HDR_VID_LEN			2
-#define AM6_EEPROM_HDR_BLD_WK_LEN		2
-#define AM6_EEPROM_HDR_BLD_YR_LEN		2
-#define AM6_EEPROM_HDR_4P_NR_LEN		6
-#define AM6_EEPROM_HDR_SERIAL_LEN		4
-
-struct ti_am6_eeprom_record_board_info {
-	char name[AM6_EEPROM_HDR_NAME_LEN];
-	char version[AM6_EEPROM_HDR_VERSION_LEN];
-	char proc_number[AM6_EEPROM_HDR_PROC_NR_LEN];
-	char variant[AM6_EEPROM_HDR_VARIANT_LEN];
-	char pcb_revision[AM6_EEPROM_HDR_PCB_REV_LEN];
-	char schematic_bom_revision[AM6_EEPROM_HDR_SCH_BOM_REV_LEN];
-	char software_revision[AM6_EEPROM_HDR_SW_REV_LEN];
-	char vendor_id[AM6_EEPROM_HDR_VID_LEN];
-	char build_week[AM6_EEPROM_HDR_BLD_WK_LEN];
-	char build_year[AM6_EEPROM_HDR_BLD_YR_LEN];
-	char board_4p_number[AM6_EEPROM_HDR_4P_NR_LEN];
-	char serial[AM6_EEPROM_HDR_SERIAL_LEN];
-} __attribute__ ((__packed__));
-
-/* Memory location to keep a copy of the AM6 board info record */
-#define TI_AM6_EEPROM_BD_INFO_DATA ((struct ti_am6_eeprom_record_board_info *) \
-					     TI_SRAM_SCRATCH_BOARD_EEPROM_START)
-
-/* AM6x TI EVM EEPROM DDR info structure */
-#define TI_AM6_EEPROM_DDR_CTRL_INSTANCE_MASK		GENMASK(1, 0)
-#define TI_AM6_EEPROM_DDR_CTRL_INSTANCE_SHIFT		0
-#define TI_AM6_EEPROM_DDR_CTRL_SPD_DATA_LOC_MASK	GENMASK(3, 2)
-#define TI_AM6_EEPROM_DDR_CTRL_SPD_DATA_LOC_NA		(0 << 2)
-#define TI_AM6_EEPROM_DDR_CTRL_SPD_DATA_LOC_BOARDID	(2 << 2)
-#define TI_AM6_EEPROM_DDR_CTRL_SPD_DATA_LOC_I2C51	(3 << 2)
-#define TI_AM6_EEPROM_DDR_CTRL_MEM_TYPE_MASK		GENMASK(5, 4)
-#define TI_AM6_EEPROM_DDR_CTRL_MEM_TYPE_DDR3		(0 << 4)
-#define TI_AM6_EEPROM_DDR_CTRL_MEM_TYPE_DDR4		(1 << 4)
-#define TI_AM6_EEPROM_DDR_CTRL_MEM_TYPE_LPDDR4		(2 << 4)
-#define TI_AM6_EEPROM_DDR_CTRL_IF_DATA_WIDTH_MASK	GENMASK(7, 6)
-#define TI_AM6_EEPROM_DDR_CTRL_IF_DATA_WIDTH_16		(0 << 6)
-#define TI_AM6_EEPROM_DDR_CTRL_IF_DATA_WIDTH_32		(1 << 6)
-#define TI_AM6_EEPROM_DDR_CTRL_IF_DATA_WIDTH_64		(2 << 6)
-#define TI_AM6_EEPROM_DDR_CTRL_DEV_DATA_WIDTH_MASK	GENMASK(9, 8)
-#define TI_AM6_EEPROM_DDR_CTRL_DEV_DATA_WIDTH_8		(0 << 8)
-#define TI_AM6_EEPROM_DDR_CTRL_DEV_DATA_WIDTH_16	(1 << 8)
-#define TI_AM6_EEPROM_DDR_CTRL_DEV_DATA_WIDTH_32	(2 << 8)
-#define TI_AM6_EEPROM_DDR_CTRL_RANKS_2			BIT(10)
-#define TI_AM6_EEPROM_DDR_CTRL_DENS_MASK		GENMASK(13, 11)
-#define TI_AM6_EEPROM_DDR_CTRL_DENS_1GB			(0 << 11)
-#define TI_AM6_EEPROM_DDR_CTRL_DENS_2GB			(1 << 11)
-#define TI_AM6_EEPROM_DDR_CTRL_DENS_4GB			(2 << 11)
-#define TI_AM6_EEPROM_DDR_CTRL_DENS_8GB			(3 << 11)
-#define TI_AM6_EEPROM_DDR_CTRL_DENS_12GB		(4 << 11)
-#define TI_AM6_EEPROM_DDR_CTRL_DENS_16GB		(5 << 11)
-#define TI_AM6_EEPROM_DDR_CTRL_DENS_24GB		(6 << 11)
-#define TI_AM6_EEPROM_DDR_CTRL_DENS_32GB		(7 << 11)
-#define TI_AM6_EEPROM_DDR_CTRL_ECC			BIT(14)
-
-struct ti_am6_eeprom_record_ddr_info {
-	u16 ddr_control;
-} __attribute__ ((__packed__));
-
-/* AM6x TI EVM EEPROM DDR SPD structure */
-#define TI_AM6_EEPROM_DDR_SPD_INSTANCE_MASK		GENMASK(1, 0)
-#define TI_AM6_EEPROM_DDR_SPD_INSTANCE_SHIFT		0
-#define TI_AM6_EEPROM_DDR_SPD_MEM_TYPE_MASK		GENMASK(4, 3)
-#define TI_AM6_EEPROM_DDR_SPD_MEM_TYPE_DDR3		(0 << 3)
-#define TI_AM6_EEPROM_DDR_SPD_MEM_TYPE_DDR4		(1 << 3)
-#define TI_AM6_EEPROM_DDR_SPD_MEM_TYPE_LPDDR4		(2 << 3)
-#define TI_AM6_EEPROM_DDR_SPD_DATA_LEN			512
-
-struct ti_am6_eeprom_record_ddr_spd {
-	u16 spd_control;
-	u8 data[TI_AM6_EEPROM_DDR_SPD_DATA_LEN];
-} __attribute__ ((__packed__));
-
-/* AM6x TI EVM EEPROM MAC info structure */
-#define TI_AM6_EEPROM_MAC_INFO_INSTANCE_MASK		GENMASK(2, 0)
-#define TI_AM6_EEPROM_MAC_INFO_INSTANCE_SHIFT		0
-#define TI_AM6_EEPROM_MAC_ADDR_COUNT_MASK		GENMASK(7, 3)
-#define TI_AM6_EEPROM_MAC_ADDR_COUNT_SHIFT		3
-#define TI_AM6_EEPROM_MAC_ADDR_MAX_COUNT		32
-
-struct ti_am6_eeprom_record_mac_info {
-	u16 mac_control;
-	u8 mac_addr[TI_AM6_EEPROM_MAC_ADDR_MAX_COUNT][TI_EEPROM_HDR_ETH_ALEN];
-} __attribute__ ((__packed__));
-
-struct ti_am6_eeprom_record {
-	struct ti_am6_eeprom_record_header header;
-	union {
-		struct ti_am6_eeprom_record_board_info board_info;
-		struct ti_am6_eeprom_record_ddr_info ddr_info;
-		struct ti_am6_eeprom_record_ddr_spd ddr_spd;
-		struct ti_am6_eeprom_record_mac_info mac_info;
-	} data;
-} __attribute__ ((__packed__));
-
-/* DRA7 EEPROM MAGIC Header identifier */
-#define DRA7_EEPROM_HEADER_MAGIC	0xAA5533EE
-#define DRA7_EEPROM_HDR_NAME_LEN	16
-#define DRA7_EEPROM_HDR_CONFIG_LEN	4
-
-/**
- * struct dra7_eeprom - This structure holds data read in from the DRA7 EVM
- *			EEPROMs.
- * @header: This holds the magic number
- * @name: The name of the board
- * @version_major: Board major version
- * @version_minor: Board minor version
- * @config: Board specific config options
- * @emif1_size: Size of DDR attached to EMIF1
- * @emif2_size: Size of DDR attached to EMIF2
- *
- * The data is this structure is read from the EEPROM on the board.
- * It is used for board detection which is based on name. It is used
- * to configure specific DRA7 boards. This allows booting of multiple
- * DRA7 boards with a single MLO and u-boot.
- */
-struct dra7_eeprom {
-	u32 header;
-	char name[DRA7_EEPROM_HDR_NAME_LEN];
-	u16 version_major;
-	u16 version_minor;
-	char config[DRA7_EEPROM_HDR_CONFIG_LEN];
-	u32 emif1_size;
-	u32 emif2_size;
-} __attribute__ ((__packed__));
-
-/**
- * struct ti_common_eeprom - Null terminated, usable EEPROM contents.
- * header:	Magic number
- * @name:	NULL terminated name
- * @version:	NULL terminated version
- * @serial:	NULL terminated serial number
- * @config:	NULL terminated Board specific config options
- * @mac_addr:	MAC addresses
- * @emif1_size:	Size of the ddr available on emif1
- * @emif2_size:	Size of the ddr available on emif2
- */
-struct ti_common_eeprom {
-	u32 header;
-	char name[TI_EEPROM_HDR_NAME_LEN + 1];
-	char version[TI_EEPROM_HDR_REV_LEN + 1];
-	char serial[TI_EEPROM_HDR_SERIAL_LEN + 1];
-	char config[TI_EEPROM_HDR_CONFIG_LEN + 1];
-	char mac_addr[TI_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
-	u64 emif1_size;
-	u64 emif2_size;
-};
-
-#define TI_EEPROM_DATA ((struct ti_common_eeprom *)\
-				TI_SRAM_SCRATCH_BOARD_EEPROM_START)
-
-/*
- * Maximum number of Ethernet MAC addresses extracted from the AM6x on-board
- * EEPROM during the initial probe and carried forward in SRAM.
- */
-#define AM6_EEPROM_HDR_NO_OF_MAC_ADDR	8
-
-/**
- * struct ti_am6_eeprom - Null terminated, usable EEPROM contents, as extracted
- *	from the AM6 on-board EEPROM. Note that we only carry a subset of data
- *	at this time to be considerate about memory consumption.
- * @header:		Magic number for data validity indication
- * @name:		NULL terminated name
- * @version:		NULL terminated version
- * @software_revision:	NULL terminated software revision
- * @serial:		Board serial number
- * @mac_addr_cnt:	Number of MAC addresses stored in this object
- * @mac_addr:		MAC addresses
- */
-struct ti_am6_eeprom {
-	u32 header;
-	char name[AM6_EEPROM_HDR_NAME_LEN + 1];
-	char version[AM6_EEPROM_HDR_VERSION_LEN + 1];
-	char software_revision[AM6_EEPROM_HDR_SW_REV_LEN + 1];
-	char serial[AM6_EEPROM_HDR_SERIAL_LEN + 1];
-	u8 mac_addr_cnt;
-	char mac_addr[AM6_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
-};
-
-#define TI_AM6_EEPROM_DATA ((struct ti_am6_eeprom *) \
-				TI_SRAM_SCRATCH_BOARD_EEPROM_START)
-
-/**
- * ti_i2c_eeprom_am_get() - Consolidated eeprom data collection for AM* TI EVMs
- * @bus_addr:	I2C bus address
- * @dev_addr:	I2C slave address
- *
- * ep in SRAM is populated by the this AM generic function that consolidates
- * the basic initialization logic common across all AM* platforms.
- */
-int ti_i2c_eeprom_am_get(int bus_addr, int dev_addr);
-
-/**
- * ti_emmc_boardid_get() - Fetch board ID information from eMMC
- *
- * ep in SRAM is populated by the this function that is currently
- * based on BeagleBone AI, but could be made more general across AM*
- * platforms.
- */
-int __maybe_unused ti_emmc_boardid_get(void);
-
-/**
- * ti_i2c_eeprom_dra7_get() - Consolidated eeprom data for DRA7 TI EVMs
- * @bus_addr:	I2C bus address
- * @dev_addr:	I2C slave address
- */
-int ti_i2c_eeprom_dra7_get(int bus_addr, int dev_addr);
-
-/**
- * ti_i2c_eeprom_am6_get() - Consolidated eeprom data for AM6x TI EVMs and
- *			     associated daughter cards, parsed into user-
- *			     provided data structures
- * @bus_addr:	I2C bus address
- * @dev_addr:	I2C slave address
- * @ep:		Pointer to structure receiving AM6-specific header data
- * @mac_addr:	Pointer to memory receiving parsed MAC addresses. May be
- *		NULL to skip MAC parsing.
- * @mac_addr_max_cnt: Maximum number of MAC addresses that can be stored into
- *		      mac_addr. May be NULL to skip MAC parsing.
- * @mac_addr_cnt: Pointer to a location returning how many MAC addressed got
- *		  actually parsed.
- */
-int __maybe_unused ti_i2c_eeprom_am6_get(int bus_addr, int dev_addr,
-					 struct ti_am6_eeprom *ep,
-					 char **mac_addr,
-					 u8 mac_addr_max_cnt,
-					 u8 *mac_addr_cnt);
-
-/**
- * ti_i2c_eeprom_am6_get_base() - Consolidated eeprom data for AM6x TI EVMs
- * @bus_addr:	I2C bus address
- * @dev_addr:	I2C slave address
- */
-int __maybe_unused ti_i2c_eeprom_am6_get_base(int bus_addr, int dev_addr);
-
-#ifdef CONFIG_TI_I2C_BOARD_DETECT
-/**
- * board_ti_is() - Board detection logic for TI EVMs
- * @name_tag:	Tag used in eeprom for the board
- *
- * Return: false if board information does not match OR eeprom wasn't read.
- *	   true otherwise
- */
-bool board_ti_is(char *name_tag);
-
-/**
- * board_ti_k3_is() - Board detection logic for TI K3 EVMs
- * @name_tag:	Tag used in eeprom for the board
- *
- * Return: false if board information does not match OR eeprom wasn't read.
- *	   true otherwise
- */
-bool board_ti_k3_is(char *name_tag);
-
-/**
- * board_ti_rev_is() - Compare board revision for TI EVMs
- * @rev_tag:	Revision tag to check in eeprom
- * @cmp_len:	How many chars to compare?
- *
- * NOTE: revision information is often messed up (hence the str len match) :(
- *
- * Return: false if board information does not match OR eeprom wasn't read.
- *	   true otherwise
- */
-bool board_ti_rev_is(char *rev_tag, int cmp_len);
-
-/**
- * board_ti_get_rev() - Get board revision for TI EVMs
- *
- * Return: Empty string if eeprom wasn't read.
- *	   Board revision otherwise
- */
-char *board_ti_get_rev(void);
-
-/**
- * board_ti_get_config() - Get board config for TI EVMs
- *
- * Return: Empty string if eeprom wasn't read.
- *	   Board config otherwise
- */
-char *board_ti_get_config(void);
-
-/**
- * board_ti_get_name() - Get board name for TI EVMs
- *
- * Return: Empty string if eeprom wasn't read.
- *	   Board name otherwise
- */
-char *board_ti_get_name(void);
-
-/**
- * board_ti_get_eth_mac_addr() - Get Ethernet MAC address from EEPROM MAC list
- * @index:	0 based index within the list of MAC addresses
- * @mac_addr:	MAC address contained at the index is returned here
- *
- * Does not sanity check the mac_addr. Whatever is stored in EEPROM is returned.
- */
-void board_ti_get_eth_mac_addr(int index, u8 mac_addr[TI_EEPROM_HDR_ETH_ALEN]);
-
-/**
- * board_ti_get_emif1_size() - Get size of the DDR on emif1 for TI EVMs
- *
- * Return: NULL if eeprom wasn't read or emif1_size is not available.
- */
-u64 board_ti_get_emif1_size(void);
-
-/**
- * board_ti_get_emif2_size() - Get size of the DDR on emif2 for TI EVMs
- *
- * Return: NULL if eeprom wasn't read or emif2_size is not available.
- */
-u64 board_ti_get_emif2_size(void);
-
-/**
- * set_board_info_env() - Setup commonly used board information environment vars
- * @name:	Name of the board
- *
- * If name is NULL, default_name is used.
- */
-void set_board_info_env(char *name);
-
-/**
- * set_board_info_env_am6() - Setup commonly used board information environment
- *			      vars for AM6-type boards
- * @name:	Name of the board
- *
- * If name is NULL, default_name is used.
- */
-void set_board_info_env_am6(char *name);
-
-/**
- * board_ti_set_ethaddr- Sets the ethaddr environment from EEPROM
- * @index: The first eth<index>addr environment variable to set
- *
- * EEPROM should be already read before calling this function.
- * The EEPROM contains 2 MAC addresses which define the MAC address
- * range (i.e. first and last MAC address).
- * This function sets the ethaddr environment variable for all
- * the available MAC addresses starting from eth<index>addr.
- */
-void board_ti_set_ethaddr(int index);
-
-/**
- * board_ti_am6_set_ethaddr- Sets the ethaddr environment from EEPROM
- * @index: The first eth<index>addr environment variable to set
- * @count: The number of MAC addresses to process
- *
- * EEPROM should be already read before calling this function. The EEPROM
- * contains n dedicated MAC addresses. This function sets the ethaddr
- * environment variable for all the available MAC addresses starting
- * from eth<index>addr.
- */
-void board_ti_am6_set_ethaddr(int index, int count);
-
-/**
- * board_ti_was_eeprom_read() - Check to see if the eeprom contents have been read
- *
- * This function is useful to determine if the eeprom has already been read and
- * its contents have already been loaded into memory. It utiltzes the magic
- * number that the header value is set to upon successful eeprom read.
- */
-bool board_ti_was_eeprom_read(void);
-
-/**
- * ti_i2c_eeprom_am_set() - Setup the eeprom data with predefined values
- * @name:	Name of the board
- * @rev:	Revision of the board
- *
- * In some cases such as in RTC-only mode, we are able to skip reading eeprom
- * and wasting i2c based initialization time by using predefined flags for
- * detecting what platform we are booting on. For those platforms, provide
- * a handy function to pre-program information.
- *
- * NOTE: many eeprom information such as serial number, mac address etc is not
- * available.
- *
- * Return: 0 if all went fine, else return error.
- */
-int ti_i2c_eeprom_am_set(const char *name, const char *rev);
-#else
-static inline bool board_ti_is(char *name_tag) { return false; };
-static inline bool board_ti_k3_is(char *name_tag) { return false; };
-static inline bool board_ti_rev_is(char *rev_tag, int cmp_len)
-{ return false; };
-static inline char *board_ti_get_rev(void) { return NULL; };
-static inline char *board_ti_get_config(void) { return NULL; };
-static inline char *board_ti_get_name(void) { return NULL; };
-static inline bool board_ti_was_eeprom_read(void) { return false; };
-static inline int ti_i2c_eeprom_am_set(const char *name, const char *rev)
-{ return -EINVAL; };
-#endif
-
-#endif	/* __BOARD_DETECT_H */
diff --git a/configs/am64x_a53_solidrun_defconfig b/configs/am64x_a53_solidrun_defconfig
index 8618bf65..296dca24 100644
--- a/configs/am64x_a53_solidrun_defconfig
+++ b/configs/am64x_a53_solidrun_defconfig
@@ -64,7 +64,7 @@ CONFIG_MTDPARTS_DEFAULT="mtdparts=fc40000.spi.0:512k(ospi.tiboot3),2m(ospi.tispl
 CONFIG_CMD_UBI=y
 CONFIG_OF_CONTROL=y
 CONFIG_SPL_OF_CONTROL=y
-CONFIG_OF_LIST="k3-am642-evm k3-am642-sk"
+CONFIG_OF_LIST="am642-solidrun"
 CONFIG_MULTI_DTB_FIT=y
 CONFIG_SPL_MULTI_DTB_FIT=y
 CONFIG_SPL_MULTI_DTB_FIT_NO_COMPRESSION=y
diff --git a/configs/am64x_r5_solidrun_defconfig b/configs/am64x_r5_solidrun_defconfig
index afd79682..a3d8ff45 100644
--- a/configs/am64x_r5_solidrun_defconfig
+++ b/configs/am64x_r5_solidrun_defconfig
@@ -69,7 +69,6 @@ CONFIG_CMD_FAT=y
 CONFIG_OF_CONTROL=y
 CONFIG_SPL_OF_CONTROL=y
 CONFIG_SPL_MULTI_DTB_FIT=y
-CONFIG_SPL_OF_LIST="k3-am642-r5-evm k3-am642-r5-sk"
 CONFIG_SPL_MULTI_DTB_FIT_NO_COMPRESSION=y
 CONFIG_ENV_IS_NOWHERE=y
 CONFIG_SYS_RELOC_GD_ENV_ADDR=y
-- 
2.25.1

